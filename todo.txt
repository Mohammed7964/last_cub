segv in this case without 0/1

NO imgs/CRATE_1D.xpm
SO imgs/DOOR_1A.xpm
WE imgs/DOOR_1E.xpm
EA imgs/DOOR_1E.xpm

C 0,0,0
F 0,0,0


/////////////////////////////////////////////////

leaks  1 (32 bytes) ROOT LEAK: 0x7f8502c0e6b0 [32]  length: 17  "imgs/CRATE_1D.xpm"
NO imgs/CRATE_1D.xpm
SO imgs/DOOR_1A.xpm
WE imgs/DOOR_1E.xpm
EA imgs/DOOR_1E.xpm

NO imgs/CRATE_1D.xpm
C 0,0,0
F 0,0,0
duplicate NO

////////////////////////////////////////////////////////

it should pass
NO imgs/CRATE_1D.xpm
SO imgs/DOOR_1A.xpm
WE imgs/DOOR_1E.xpm
EA imgs/DOOR_1E.xpm

C 0,  1   ,0
F 0,00000000000000000000000000000000000000000000000000000000000000,0

////////////////////////////////////////////////
should pass
             11
            11N11
              11
/////
11
1N1
11
//////////
111
1N1
111









static void	free_and_set_value(char **old_value, char *new_value)
{
	free(*old_value);
	*old_value = new_value;
}

static void	handle_texture_or_color_key(t_cub *cub, char *key, char *value)
{
	if (strcmp(key, "NO") == 0)
		free_and_set_value(&cub->north_texture, value);
	else if (strcmp(key, "SO") == 0)
		free_and_set_value(&cub->south_texture, value);
	else if (strcmp(key, "WE") == 0)
		free_and_set_value(&cub->west_texture, value);
	else if (strcmp(key, "EA") == 0)
		free_and_set_value(&cub->east_texture, value);
	else if (strcmp(key, "F") == 0)
		free_and_set_value(&cub->_F, value);
	else if (strcmp(key, "C") == 0)
		free_and_set_value(&cub->_C, value);
	else
		free(value);
}

static void	set_texture_or_color(t_cub *cub, char *key, char *value)
{
	if (key && value)
		handle_texture_or_color_key(cub, key, value);
}
